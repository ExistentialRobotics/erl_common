import collections.abc
import flags
import numpy
import numpy.typing
import typing
from typing import ClassVar, overload

class GridMap2D8u:
    data: Tensor2D8u
    info: GridMapInfo2Df
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, value: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data: Tensor2D8u) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data_init_func: collections.abc.Callable[[], int]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8, '[m, 1]']) -> None: ...

class GridMap2Dd:
    data: Tensor2Dd
    info: GridMapInfo2Dd
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Dd) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Dd, value: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Dd, data: Tensor2Dd) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Dd, data_init_func: collections.abc.Callable[[], float]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Dd, data: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]']) -> None: ...

class GridMap2Df:
    data: Tensor2Df
    info: GridMapInfo2Df
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, value: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data: Tensor2Df) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data_init_func: collections.abc.Callable[[], float]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]']) -> None: ...

class GridMap2Di:
    data: Tensor2Di
    info: GridMapInfo2Df
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, value: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data: Tensor2Di) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data_init_func: collections.abc.Callable[[], int]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo2Df, data: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]']) -> None: ...

class GridMap3D8u:
    data: Tensor3D8u
    info: GridMapInfo3Df
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, value: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data: Tensor3D8u) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data_init_func: collections.abc.Callable[[], int]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8, '[m, 1]']) -> None: ...

class GridMap3Dd:
    data: Tensor3Dd
    info: GridMapInfo3Dd
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Dd) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Dd, value: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Dd, data: Tensor3Dd) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Dd, data_init_func: collections.abc.Callable[[], float]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Dd, data: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]']) -> None: ...

class GridMap3Df:
    data: Tensor3Df
    info: GridMapInfo3Df
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, value: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data: Tensor3Df) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data_init_func: collections.abc.Callable[[], float]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]']) -> None: ...

class GridMap3Di:
    data: Tensor3Di
    info: GridMapInfo3Df
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, value: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data: Tensor3Di) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data_init_func: collections.abc.Callable[[], int]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfo3Df, data: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]']) -> None: ...

class GridMapDrawer2Dd:
    grid_map_info: GridMapInfo2Dd
    def __init__(self, grid_map_info: GridMapInfo2Dd) -> None: ...
    def draw_contour(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, contour: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> Mat: ...
    def draw_contour_inplace(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, contour: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> None: ...
    def draw_polyline(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, closed: bool, points: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> Mat: ...
    def draw_polyline_inplace(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, closed: bool, points: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> None: ...
    def draw_rays(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, starts: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]'], ends: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> Mat: ...
    def draw_rays_inplace(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, starts: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]'], ends: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> None: ...
    def draw_segments(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, starts: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous'], ends: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> Mat: ...
    def draw_segments_inplace(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, starts: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous'], ends: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> None: ...
    def reset_image(self) -> None: ...
    def show_image(self, title: str) -> None: ...

class GridMapDrawer2Df:
    grid_map_info: GridMapInfo2Df
    def __init__(self, grid_map_info: GridMapInfo2Df) -> None: ...
    def draw_contour(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, contour: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> Mat: ...
    def draw_contour_inplace(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, contour: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> None: ...
    def draw_polyline(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, closed: bool, points: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> Mat: ...
    def draw_polyline_inplace(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, closed: bool, points: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> None: ...
    def draw_rays(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, starts: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, 1]'], ends: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> Mat: ...
    def draw_rays_inplace(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, starts: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, 1]'], ends: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> None: ...
    def draw_segments(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, starts: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous'], ends: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> Mat: ...
    def draw_segments_inplace(self, mat: Mat, color: Scalar, thickness: typing.SupportsInt, starts: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous'], ends: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> None: ...
    def reset_image(self) -> None: ...
    def show_image(self, title: str) -> None: ...

class GridMapInfo2Dd:
    @overload
    def __init__(self, min: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]'], resolution: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]'], padding: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]']) -> None: ...
    @overload
    def __init__(self, map_shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]'], min: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[2, 1]']) -> None: ...
    @overload
    def extend(self, size: typing.SupportsInt, min: typing.SupportsFloat, max: typing.SupportsFloat, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    @overload
    def extend(self, min: typing.SupportsFloat, max: typing.SupportsFloat, resolution: typing.SupportsFloat, padding: typing.SupportsInt, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    def generate_grid_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def generate_meter_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]']: ...
    def get_dim_lin_space(self, dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    def get_grid_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def get_metric_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]']: ...
    def get_pixel_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def grid_to_index(self, grid: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'], c_stride: bool) -> int: ...
    @overload
    def grid_to_meter_at_dim(self, grid_value: typing.SupportsInt, dim: typing.SupportsInt) -> float: ...
    @overload
    def grid_to_meter_at_dim(self, grid_values: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    def grid_to_meter_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]']: ...
    def grid_to_meter_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]']: ...
    def grid_to_pixel_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def grid_to_pixel_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def in_grids(self, grid_point: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']) -> bool: ...
    def in_map(self, meter_point: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']) -> bool: ...
    def index_to_grid(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    def index_to_pixel(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    def max_at(self, dim: typing.SupportsInt) -> float: ...
    @overload
    def meter_to_grid_at_dim(self, meter_value: typing.SupportsFloat, dim: typing.SupportsInt) -> int: ...
    @overload
    def meter_to_grid_at_dim(self, meter_values: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def meter_to_grid_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def meter_to_grid_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def meter_to_pixel_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def meter_to_pixel_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def min_at(self, dim: typing.SupportsInt) -> float: ...
    def pixel_to_grid_for_points(self, pixel_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def pixel_to_grid_for_vectors(self, pixel_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def pixel_to_index(self, pixel: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'], c_stride: bool) -> int: ...
    def pixel_to_meter_for_points(self, pixel_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]']: ...
    def pixel_to_meter_for_vectors(self, pixel_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]']: ...
    def ray_casting(self, start: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]'], end: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def resolution_at(self, dim: typing.SupportsInt) -> float: ...
    def shape_at(self, dim: typing.SupportsInt) -> int: ...
    def squeeze(self, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    @property
    def center(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']: ...
    @property
    def center_grid(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    @property
    def dims(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def length(self) -> int: ...
    @property
    def max(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']: ...
    @property
    def min(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']: ...
    @property
    def resolution(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, 1]']: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    @property
    def size(self) -> int: ...
    @property
    def width(self) -> int: ...

class GridMapInfo2Df:
    @overload
    def __init__(self, min: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[2, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[2, 1]'], resolution: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[2, 1]'], padding: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]']) -> None: ...
    @overload
    def __init__(self, map_shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]'], min: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[2, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[2, 1]']) -> None: ...
    @overload
    def extend(self, size: typing.SupportsInt, min: typing.SupportsFloat, max: typing.SupportsFloat, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    @overload
    def extend(self, min: typing.SupportsFloat, max: typing.SupportsFloat, resolution: typing.SupportsFloat, padding: typing.SupportsInt, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    def generate_grid_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def generate_meter_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]']: ...
    def get_dim_lin_space(self, dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    def get_grid_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def get_metric_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]']: ...
    def get_pixel_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def grid_to_index(self, grid: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'], c_stride: bool) -> int: ...
    @overload
    def grid_to_meter_at_dim(self, grid_value: typing.SupportsInt, dim: typing.SupportsInt) -> float: ...
    @overload
    def grid_to_meter_at_dim(self, grid_values: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    def grid_to_meter_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]']: ...
    def grid_to_meter_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]']: ...
    def grid_to_pixel_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def grid_to_pixel_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def in_grids(self, grid_point: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']) -> bool: ...
    def in_map(self, meter_point: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, 1]']) -> bool: ...
    def index_to_grid(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    def index_to_pixel(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    def max_at(self, dim: typing.SupportsInt) -> float: ...
    @overload
    def meter_to_grid_at_dim(self, meter_value: typing.SupportsFloat, dim: typing.SupportsInt) -> int: ...
    @overload
    def meter_to_grid_at_dim(self, meter_values: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def meter_to_grid_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def meter_to_grid_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def meter_to_pixel_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def meter_to_pixel_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def min_at(self, dim: typing.SupportsInt) -> float: ...
    def pixel_to_grid_for_points(self, pixel_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def pixel_to_grid_for_vectors(self, pixel_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def pixel_to_index(self, pixel: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'], c_stride: bool) -> int: ...
    def pixel_to_meter_for_points(self, pixel_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]']: ...
    def pixel_to_meter_for_vectors(self, pixel_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]']: ...
    def ray_casting(self, start: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]'], end: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def resolution_at(self, dim: typing.SupportsInt) -> float: ...
    def shape_at(self, dim: typing.SupportsInt) -> int: ...
    def squeeze(self, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    @property
    def center(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, 1]']: ...
    @property
    def center_grid(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    @property
    def dims(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def length(self) -> int: ...
    @property
    def max(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, 1]']: ...
    @property
    def min(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, 1]']: ...
    @property
    def resolution(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, 1]']: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    @property
    def size(self) -> int: ...
    @property
    def width(self) -> int: ...

class GridMapInfo3Dd:
    @overload
    def __init__(self, min: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[3, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[3, 1]'], resolution: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[3, 1]'], padding: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[3, 1]']) -> None: ...
    @overload
    def __init__(self, map_shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[3, 1]'], min: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[3, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[3, 1]']) -> None: ...
    @overload
    def extend(self, size: typing.SupportsInt, min: typing.SupportsFloat, max: typing.SupportsFloat, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    @overload
    def extend(self, min: typing.SupportsFloat, max: typing.SupportsFloat, resolution: typing.SupportsFloat, padding: typing.SupportsInt, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    def generate_grid_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, n]']: ...
    def generate_meter_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, n]']: ...
    def get_dim_lin_space(self, dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    def grid_to_index(self, grid: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]'], c_stride: bool) -> int: ...
    @overload
    def grid_to_meter_at_dim(self, grid_value: typing.SupportsInt, dim: typing.SupportsInt) -> float: ...
    @overload
    def grid_to_meter_at_dim(self, grid_values: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    def grid_to_meter_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, n]']: ...
    def grid_to_meter_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]']: ...
    def in_grids(self, grid_point: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']) -> bool: ...
    def in_map(self, meter_point: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, 1]']) -> bool: ...
    def index_to_grid(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']: ...
    def max_at(self, dim: typing.SupportsInt) -> float: ...
    @overload
    def meter_to_grid_at_dim(self, meter_value: typing.SupportsFloat, dim: typing.SupportsInt) -> int: ...
    @overload
    def meter_to_grid_at_dim(self, meter_values: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def meter_to_grid_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, n]']: ...
    def meter_to_grid_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def min_at(self, dim: typing.SupportsInt) -> float: ...
    def ray_casting(self, start: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]'], end: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def resolution_at(self, dim: typing.SupportsInt) -> float: ...
    def shape_at(self, dim: typing.SupportsInt) -> int: ...
    def squeeze(self, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    @property
    def center(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, 1]']: ...
    @property
    def center_grid(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']: ...
    @property
    def dims(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def length(self) -> int: ...
    @property
    def max(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, 1]']: ...
    @property
    def min(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, 1]']: ...
    @property
    def resolution(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[3, 1]']: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']: ...
    @property
    def size(self) -> int: ...
    @property
    def width(self) -> int: ...

class GridMapInfo3Df:
    @overload
    def __init__(self, min: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[3, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[3, 1]'], resolution: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[3, 1]'], padding: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[3, 1]']) -> None: ...
    @overload
    def __init__(self, map_shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[3, 1]'], min: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[3, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[3, 1]']) -> None: ...
    @overload
    def extend(self, size: typing.SupportsInt, min: typing.SupportsFloat, max: typing.SupportsFloat, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    @overload
    def extend(self, min: typing.SupportsFloat, max: typing.SupportsFloat, resolution: typing.SupportsFloat, padding: typing.SupportsInt, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    def generate_grid_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, n]']: ...
    def generate_meter_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[3, n]']: ...
    def get_dim_lin_space(self, dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    def grid_to_index(self, grid: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]'], c_stride: bool) -> int: ...
    @overload
    def grid_to_meter_at_dim(self, grid_value: typing.SupportsInt, dim: typing.SupportsInt) -> float: ...
    @overload
    def grid_to_meter_at_dim(self, grid_values: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    def grid_to_meter_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[3, n]']: ...
    def grid_to_meter_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]']: ...
    def in_grids(self, grid_point: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']) -> bool: ...
    def in_map(self, meter_point: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[3, 1]']) -> bool: ...
    def index_to_grid(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']: ...
    def max_at(self, dim: typing.SupportsInt) -> float: ...
    @overload
    def meter_to_grid_at_dim(self, meter_value: typing.SupportsFloat, dim: typing.SupportsInt) -> int: ...
    @overload
    def meter_to_grid_at_dim(self, meter_values: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def meter_to_grid_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[3, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, n]']: ...
    def meter_to_grid_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def min_at(self, dim: typing.SupportsInt) -> float: ...
    def ray_casting(self, start: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]'], end: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def resolution_at(self, dim: typing.SupportsInt) -> float: ...
    def shape_at(self, dim: typing.SupportsInt) -> int: ...
    def squeeze(self, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    @property
    def center(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[3, 1]']: ...
    @property
    def center_grid(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']: ...
    @property
    def dims(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def length(self) -> int: ...
    @property
    def max(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[3, 1]']: ...
    @property
    def min(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[3, 1]']: ...
    @property
    def resolution(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[3, 1]']: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']: ...
    @property
    def size(self) -> int: ...
    @property
    def width(self) -> int: ...

class GridMapInfoXDd:
    @overload
    def __init__(self, min: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]'], resolution: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]'], padding: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, map_shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], min: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]']) -> None: ...
    @overload
    def extend(self, size: typing.SupportsInt, min: typing.SupportsFloat, max: typing.SupportsFloat, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    @overload
    def extend(self, min: typing.SupportsFloat, max: typing.SupportsFloat, resolution: typing.SupportsFloat, padding: typing.SupportsInt, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    def generate_grid_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def generate_meter_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]']: ...
    def get_dim_lin_space(self, dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    def get_grid_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def get_metric_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]']: ...
    def get_pixel_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def grid_to_index(self, grid: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], c_stride: bool) -> int: ...
    @overload
    def grid_to_meter_at_dim(self, grid_value: typing.SupportsInt, dim: typing.SupportsInt) -> float: ...
    @overload
    def grid_to_meter_at_dim(self, grid_values: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    def grid_to_meter_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]']: ...
    def grid_to_meter_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]']: ...
    def grid_to_pixel_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def grid_to_pixel_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def in_grids(self, grid_point: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']) -> bool: ...
    def in_map(self, meter_point: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']) -> bool: ...
    def index_to_grid(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def index_to_pixel(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def max_at(self, dim: typing.SupportsInt) -> float: ...
    @overload
    def meter_to_grid_at_dim(self, meter_value: typing.SupportsFloat, dim: typing.SupportsInt) -> int: ...
    @overload
    def meter_to_grid_at_dim(self, meter_values: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def meter_to_grid_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def meter_to_grid_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def meter_to_pixel_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def meter_to_pixel_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def min_at(self, dim: typing.SupportsInt) -> float: ...
    def pixel_to_grid_for_points(self, pixel_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def pixel_to_grid_for_vectors(self, pixel_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def pixel_to_index(self, pixel: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], c_stride: bool) -> int: ...
    def pixel_to_meter_for_points(self, pixel_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]']: ...
    def pixel_to_meter_for_vectors(self, pixel_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[2, n]']: ...
    def ray_casting(self, start: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]'], end: typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def resolution_at(self, dim: typing.SupportsInt) -> float: ...
    def shape_at(self, dim: typing.SupportsInt) -> int: ...
    def squeeze(self, dim: typing.SupportsInt) -> GridMapInfoXDd: ...
    @property
    def center(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    @property
    def center_grid(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def dims(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def length(self) -> int: ...
    @property
    def max(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    @property
    def min(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    @property
    def resolution(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, 1]']: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...
    @property
    def width(self) -> int: ...

class GridMapInfoXDf:
    @overload
    def __init__(self, min: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]'], resolution: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]'], padding: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, map_shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], min: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]'], max: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]']) -> None: ...
    @overload
    def extend(self, size: typing.SupportsInt, min: typing.SupportsFloat, max: typing.SupportsFloat, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    @overload
    def extend(self, min: typing.SupportsFloat, max: typing.SupportsFloat, resolution: typing.SupportsFloat, padding: typing.SupportsInt, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    def generate_grid_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def generate_meter_coordinates(self, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]']: ...
    def get_dim_lin_space(self, dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    def get_grid_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def get_metric_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]']: ...
    def get_pixel_coordinates_of_filled_metric_polygon(self, polygon_metric_vertices: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def grid_to_index(self, grid: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], c_stride: bool) -> int: ...
    @overload
    def grid_to_meter_at_dim(self, grid_value: typing.SupportsInt, dim: typing.SupportsInt) -> float: ...
    @overload
    def grid_to_meter_at_dim(self, grid_values: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    def grid_to_meter_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]']: ...
    def grid_to_meter_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]']: ...
    def grid_to_pixel_for_points(self, grid_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def grid_to_pixel_for_vectors(self, grid_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def in_grids(self, grid_point: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']) -> bool: ...
    def in_map(self, meter_point: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']) -> bool: ...
    def index_to_grid(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def index_to_pixel(self, index: typing.SupportsInt, c_stride: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def max_at(self, dim: typing.SupportsInt) -> float: ...
    @overload
    def meter_to_grid_at_dim(self, meter_value: typing.SupportsFloat, dim: typing.SupportsInt) -> int: ...
    @overload
    def meter_to_grid_at_dim(self, meter_values: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]'], dim: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    def meter_to_grid_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def meter_to_grid_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def meter_to_pixel_for_points(self, meter_points: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def meter_to_pixel_for_vectors(self, meter_vectors: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def min_at(self, dim: typing.SupportsInt) -> float: ...
    def pixel_to_grid_for_points(self, pixel_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def pixel_to_grid_for_vectors(self, pixel_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]']: ...
    def pixel_to_index(self, pixel: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], c_stride: bool) -> int: ...
    def pixel_to_meter_for_points(self, pixel_points: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]']: ...
    def pixel_to_meter_for_vectors(self, pixel_vectors: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, n]', 'flags.f_contiguous']) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[2, n]']: ...
    def ray_casting(self, start: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]'], end: typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, n]']: ...
    def resolution_at(self, dim: typing.SupportsInt) -> float: ...
    def shape_at(self, dim: typing.SupportsInt) -> int: ...
    def squeeze(self, dim: typing.SupportsInt) -> GridMapInfoXDf: ...
    @property
    def center(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    @property
    def center_grid(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def dims(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def length(self) -> int: ...
    @property
    def max(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    @property
    def min(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    @property
    def resolution(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float32], '[m, 1]']: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...
    @property
    def width(self) -> int: ...

class GridMapXD8u:
    data: TensorXD8u
    info: GridMapInfoXDf
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, value: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data: TensorXD8u) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data_init_func: collections.abc.Callable[[], int]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8, '[m, 1]']) -> None: ...

class GridMapXDd:
    data: TensorXDd
    info: GridMapInfoXDd
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDd) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDd, value: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDd, data: TensorXDd) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDd, data_init_func: collections.abc.Callable[[], float]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDd, data: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]']) -> None: ...

class GridMapXDf:
    data: TensorXDf
    info: GridMapInfoXDf
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, value: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data: TensorXDf) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data_init_func: collections.abc.Callable[[], float]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]']) -> None: ...

class GridMapXDi:
    data: TensorXDi
    info: GridMapInfoXDf
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, value: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data: TensorXDi) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data_init_func: collections.abc.Callable[[], int]) -> None: ...
    @overload
    def __init__(self, grid_map_info: GridMapInfoXDf, data: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]']) -> None: ...

class Logging:
    class Level:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kDebug: ClassVar[Logging.Level] = ...
        kError: ClassVar[Logging.Level] = ...
        kInfo: ClassVar[Logging.Level] = ...
        kSilent: ClassVar[Logging.Level] = ...
        kWarn: ClassVar[Logging.Level] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kDebug: ClassVar[Logging.Level] = ...
    kError: ClassVar[Logging.Level] = ...
    kInfo: ClassVar[Logging.Level] = ...
    kSilent: ClassVar[Logging.Level] = ...
    kWarn: ClassVar[Logging.Level] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def debug(msg: str) -> None: ...
    @staticmethod
    def error(msg: str) -> None: ...
    @staticmethod
    def failure(msg: str) -> str: ...
    @staticmethod
    def fatal(msg: str) -> None: ...
    @staticmethod
    def get_date_str() -> str: ...
    @staticmethod
    def get_date_time_str() -> str: ...
    @staticmethod
    def get_level() -> Logging.Level: ...
    @staticmethod
    def get_time_stamp() -> str: ...
    @staticmethod
    def get_time_str() -> str: ...
    @staticmethod
    def info(msg: str) -> None: ...
    @staticmethod
    def set_level(arg0: Logging.Level) -> None: ...
    @staticmethod
    def success(msg: str) -> None: ...
    @staticmethod
    def warn(msg: str) -> None: ...

class Tensor2D8u:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], int]) -> None: ...
    def fill(self, value: typing.SupportsInt) -> None: ...
    def get_slice(self, *args, **kwargs): ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']) -> int: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> int: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'], value: typing.SupportsInt) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsInt) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class Tensor2Dd:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], float]) -> None: ...
    def fill(self, value: typing.SupportsFloat) -> None: ...
    def get_slice(self, *args, **kwargs): ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']) -> float: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> float: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'], value: typing.SupportsFloat) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsFloat) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class Tensor2Df:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float32]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], float]) -> None: ...
    def fill(self, value: typing.SupportsFloat) -> None: ...
    def get_slice(self, *args, **kwargs): ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']) -> float: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> float: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'], value: typing.SupportsFloat) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsFloat) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class Tensor2Di:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.int32]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], int]) -> None: ...
    def fill(self, value: typing.SupportsInt) -> None: ...
    def get_slice(self, *args, **kwargs): ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']) -> int: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> int: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'], value: typing.SupportsInt) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsInt) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class Tensor3D8u:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], int]) -> None: ...
    def fill(self, value: typing.SupportsInt) -> None: ...
    def get_slice(self, *args, **kwargs): ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']) -> int: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> int: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]'], value: typing.SupportsInt) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsInt) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class Tensor3Dd:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], float]) -> None: ...
    def fill(self, value: typing.SupportsFloat) -> None: ...
    def get_slice(self, *args, **kwargs): ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']) -> float: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> float: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]'], value: typing.SupportsFloat) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsFloat) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class Tensor3Df:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float32]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], float]) -> None: ...
    def fill(self, value: typing.SupportsFloat) -> None: ...
    def get_slice(self, *args, **kwargs): ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']) -> float: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> float: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]'], value: typing.SupportsFloat) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsFloat) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class Tensor3Di:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.int32]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], int]) -> None: ...
    def fill(self, value: typing.SupportsInt) -> None: ...
    def get_slice(self, *args, **kwargs): ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]']) -> int: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> int: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[3, 1]'], value: typing.SupportsInt) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsInt) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class TensorXD8u:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.uint8, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], int]) -> None: ...
    def fill(self, value: typing.SupportsInt) -> None: ...
    def get_slice(self, dims_to_remove: collections.abc.Sequence[typing.SupportsInt], dim_indices_at_removed: collections.abc.Sequence[typing.SupportsInt]) -> TensorXD8u: ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']) -> int: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> int: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], value: typing.SupportsInt) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsInt) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class TensorXDd:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], float]) -> None: ...
    def fill(self, value: typing.SupportsFloat) -> None: ...
    def get_slice(self, dims_to_remove: collections.abc.Sequence[typing.SupportsInt], dim_indices_at_removed: collections.abc.Sequence[typing.SupportsInt]) -> TensorXDd: ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']) -> float: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> float: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], value: typing.SupportsFloat) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsFloat) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class TensorXDf:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float32]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.float32, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], float]) -> None: ...
    def fill(self, value: typing.SupportsFloat) -> None: ...
    def get_slice(self, dims_to_remove: collections.abc.Sequence[typing.SupportsInt], dim_indices_at_removed: collections.abc.Sequence[typing.SupportsInt]) -> TensorXDf: ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']) -> float: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> float: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], value: typing.SupportsFloat) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsFloat) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class TensorXDi:
    @overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.int32]) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], constant: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]']) -> None: ...
    @overload
    def __init__(self, shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], data_init_func: collections.abc.Callable[[], int]) -> None: ...
    def fill(self, value: typing.SupportsInt) -> None: ...
    def get_slice(self, dims_to_remove: collections.abc.Sequence[typing.SupportsInt], dim_indices_at_removed: collections.abc.Sequence[typing.SupportsInt]) -> TensorXDi: ...
    @overload
    def __getitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']) -> int: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> int: ...
    @overload
    def __setitem__(self, coords: typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]'], value: typing.SupportsInt) -> None: ...
    @overload
    def __setitem__(self, index: typing.SupportsInt, value: typing.SupportsInt) -> None: ...
    @property
    def dims(self) -> int: ...
    @property
    def is_row_major(self) -> bool: ...
    @property
    def shape(self) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
    @property
    def size(self) -> int: ...

class YamlableBase:
    def __init__(self, *args, **kwargs) -> None: ...
    def as_yaml_file(self, yaml_file: str) -> None: ...
    def as_yaml_string(self) -> str: ...
    def from_yaml_file(self, yaml_file: str) -> bool: ...
    def from_yaml_string(self, yaml_str: str) -> bool: ...

@overload
def compute_c_strides(shape: collections.abc.Sequence[typing.SupportsInt], item_size: typing.SupportsInt) -> list[int]: ...
@overload
def compute_c_strides(shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], item_size: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
@overload
def compute_f_strides(shape: collections.abc.Sequence[typing.SupportsInt], item_size: typing.SupportsInt) -> list[int]: ...
@overload
def compute_f_strides(shape: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[m, 1]'], item_size: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[m, 1]']: ...
def set_global_random_seed(seed: typing.SupportsInt) -> None: ...
